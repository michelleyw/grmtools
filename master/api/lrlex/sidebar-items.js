initSidebarItems({"enum":[["LexErrorKind","The various different possible Lex parser errors."],["LexerKind",""],["Visibility","Specify the visibility of the module generated by [CTLexerBuilder]."]],"fn":[["build_lex",""],["ct_token_map","Create a Rust module named `mod_name` that can be imported with `lrlex_mod!(mod_name)`. The module contains one `const` `StorageT` per token in `token_map`, with the token prefixed by `T_`. For example with `StorageT` `u8`, `mod_name` `x`, and `token_map` `HashMap{\"ID\": 0, \"INT\": 1}` the generated module will look roughly as follows:"]],"macro":[["lrlex_mod","A convenience macro for including statically compiled `.l` files. A file `src/a/b/c.l` processed by [CTLexerBuilder::lexer_in_src_dir] can then be used in a crate with `lrlex_mod!(\"a/b/c.l\")`."]],"struct":[["CTLexer","An interface to the result of [CTLexerBuilder::build()]."],["CTLexerBuilder","A `CTLexerBuilder` allows one to specify the criteria for building a statically generated lexer."],["DefaultLexeme","lrlexâ€™s standard lexeme struct: all lexemes are instances of this struct."],["LRNonStreamingLexer","An `LRNonStreamingLexer` holds a reference to a string and can lex it into [lrpar::Lexeme]s. Although the struct is tied to a single string, no guarantees are made about whether the lexemes are cached or not."],["LRNonStreamingLexerDef","This struct represents, in essence, a .l file in memory. From it one can produce an [LRNonStreamingLexer] which actually lexes inputs."],["LexBuildError","Any error from the Lex parser returns an instance of this struct."]],"trait":[["LexerDef","Methods which all lexer definitions must implement."]],"type":[["LexBuildResult",""],["LexerBuilder",""],["NonStreamingLexerDef",""]]});